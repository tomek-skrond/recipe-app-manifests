name: "Cluster Preparation"

on:
  repository_dispatch:
    types: [trigger-workflow]
  push:
    branches:
      - test
      - master

env:
    # public vars
    CLUSTER_STATIC_IP: ${{ vars.CLUSTER_STATIC_IP }}
    BUCKET_NAME: ${{ vars.BUCKET_NAME }}
    LETSENCRYPT_EMAIL: ${{ vars.EMAIL }}

    # private vars - pipeline
    CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
    CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
    CLUSTER_NAME: ${{ secrets.CLUSTER_NAME }}
    GOOGLE_CREDENTIALS: ${{ secrets.GOOGLE_CREDENTIALS }}
    COMPUTE_SERVICE_ACCOUNT: ${{ secrets.COMPUTE_ENGINE_SERVICE_ACCOUNT }} #Service account to associate to the nodes in the cluster	any	n/a	yes
    CLUSTER_REGION: ${{ secrets.REGION }}

    # terraform vars
    TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
    TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ZONE_ID }}

jobs:
  setup-gke-cluster:
    name: 'Deploy cluster resources'
    runs-on: ubuntu-latest
    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
    - name: Checkout
      uses: actions/checkout@v4
    # Alternative option - authentication via credentials json
    - id: 'auth'
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ env.GOOGLE_CREDENTIALS }}'
  
    - id: 'get-credentials'
      uses: 'google-github-actions/get-gke-credentials@v2'
      with:
        cluster_name: ${{ env.CLUSTER_NAME }}
        location: ${{ env.CLUSTER_REGION }}
        
    - id: 'install-argocd'
      run: |
        if kubectl get namespace argocd &> /dev/null; then
        echo "Namespace argocd already exists."
        else
            kubectl create namespace argocd
            echo "Namespace argocd created."
        fi
        kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
        
    - name: 'Deploy argocd application manifest'
      id: 'argocd-manifest'
      run: |
        kubectl apply -f argocd/
        
    - name: "install cert manager"
      id: 'cert-manager'
      run: |
        kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.14.4/cert-manager.yaml
    - name: "deploy configmap and secret"
      run: |
        cat <<EOF > ./recipe-app/configmap.yaml
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: postgres-config
          namespace: recipe-app
        data:
          postgres-url: postgres
        EOF
        
        cat <<EOF > ./recipe-app/secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: postgres-secret
          namespace: recipe-app
        type: Opaque
        data:
          postgres-pass: ${{ secrets.POSTGRES_PASSWORD }}
          postgres-user: ${{ secrets.POSTGRES_USER }}
          postgres-dbname: ${{ secrets.POSTGRES_DATABASE }}
          postgres-sslmode: ${{ secrets.POSTGRES_SSLMODE }}
        EOF
    - name: "apply ingress controller"
      id: 'apply-ingress'
      run: |
        cat <<EOF > ./recipe-app/ingress.yaml
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: gke-ingress
          namespace: recipe-app
          annotations:
            kubernetes.io/ingress.allow-http: "true"
            kubernetes.io/ingress.global-static-ip-name: ${{ env.CLUSTER_STATIC_IP }}
            acme.cert-manager.io/http01-edit-in-place: "true"
            cert-manager.io/issuer: letsencrypt-production
        spec:
          tls:
            - secretName: web-ssl
              hosts:
                - recipes.tscrond.com
          ingressClassName: "gce"
          defaultBackend:
            service:
              name: recipe-app
              port:
                number: 80
          rules:
          - host: "recipes.tscrond.com"
            http:
              paths:
              - path: "/*"
                pathType: ImplementationSpecific
                backend:
                  service:
                    name: recipe-app
                    port:
                      number: 80
        EOF
        
        kubectl apply -f ./recipe-app/configmap.yaml
        kubectl apply -f ./recipe-app/secret.yaml
        kubectl apply -f ./recipe-app/deployment/postgres/
        kubectl apply -f ./recipe-app/deployment/app/
        kubectl apply -f ./recipe-app/ingress.yaml
        
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v1
    - name: "create cloudflare dns records"
      id: 'tf-cloudflare'
      run: |
        timeout=$((SECONDS+300))  # Set timeout to 5 minutes from current time
        
        EXTERNAL_IP=$(kubectl get svc recipe-app -n recipe-app | grep 'recipe-app' | awk '{print $4}')
        while [ $SECONDS -lt $timeout ]; do
            EXTERNAL_IP=$(kubectl get svc -n recipe-app | grep 'recipe-app' | awk '{print $4}')
            if [[ "$EXTERNAL_IP" != "<pending>" && "$EXTERNAL_IP" != "<none>" && "$EXTERNAL_IP" != "" ]]; then
                echo "EXTERNAL-IP for recipe-app is now: $EXTERNAL_IP"
                break
            else
                echo "Waiting for EXTERNAL-IP to be assigned for recipe-app..."
                sleep 10  # Adjust the sleep interval as needed
            fi
        done
        if [ "$EXTERNAL_IP" == "<pending>" ]; then
          echo "Timeout reached. External IP not obtained within 5 minutes."
          exit 1
        fi

        export TF_VAR_service_ip=$(kubectl get svc recipe-app -o jsonpath='{.status.loadBalancer.ingress[0].ip}' -n recipe-app)

        terraform init -backend-config="bucket=${{ env.BUCKET_NAME }}"
        terraform apply -auto-approve -input=false -lock=false

    - name: 'deploy cert manager'
      run: |
        cat <<EOF > ./recipe-app/certmanager-secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          namespace: recipe-app
          name: web-ssl
        type: kubernetes.io/tls
        stringData:
          tls.key: ""
          tls.crt: ""
        EOF

        cat <<EOF > ./recipe-app/issuer.yaml
        apiVersion: cert-manager.io/v1
        kind: Issuer
        metadata:
          namespace: recipe-app
          name: letsencrypt-production
        spec:
          acme:
            server: https://acme-v02.api.letsencrypt.org/directory
            email: ${{ env.LETSENCRYPT_EMAIL }}
            privateKeySecretRef:
              name: letsencrypt-production
            solvers:
            - http01:
                ingress:
                  name: gke-ingress
        EOF
        kubectl apply -f ./recipe-app/certmanager-secret.yaml
        kubectl apply -f ./recipe-app/issuer.yaml
# - name: 'install helm'
#   run: |
#     curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
#     chmod 700 get_helm.sh
#     ./get_helm.sh
# - name: 'install externaldns using helm'
#   run: |
#     if kubectl get secret cloudflare-api-key &> /dev/null; then
#       echo "Secret cloudflare-api-key already exists."
#     else
#       kubectl create secret generic cloudflare-api-key --from-literal=API_KEY=${{ env.CLOUDFLARE_API_TOKEN }} --from-literal=CF_API_EMAIL=${{ env.CLOUDFLARE_API_EMAIL }}
#       helm upgrade --install external-dns external-dns/external-dns --values ./externaldns/values.yaml
#       echo "Secret cloudflare-api-key created."
#     fi

# cat <<EOF >./recipe-app/ingress-patch.yaml
# apiVersion: networking.k8s.io/v1
# kind: Ingress
# metadata:
#   annotations:
#     kubernetes.io/ingress.global-static-ip-name: ${{ env.CLUSTER_STATIC_IP }}
# EOF

# cat <<EOF >./recipe-app/kustomization.yaml
# apiVersion: kustomize.config.k8s.io/v1beta1
# kind: Kustomization

# resources:
# - ingress-controller.yaml

# patches:
# - target:
#     kind: Ingress
#     name: gke-ingress
#     namespace: default
#     version: networking.k8s.io/v1
#     group: networking.k8s.io
#   # patch content should be specified inline
#   patch: | 
#     - op: replace
#       path: /metadata/annotations/kubernetes.io~1ingress.global-static-ip-name
#       value: ${{ env.CLUSTER_STATIC_IP }}
